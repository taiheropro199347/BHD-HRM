{"version":3,"file":"input.js","sources":["../../../BlazorComponent.Web/src/events/EventType.ts","../../../BlazorComponent.Web/src/input.ts"],"sourcesContent":["// see https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web.JS/src/Rendering/Events/EventTypes.ts\r\n// updated at 2022/08/31\r\n\r\nexport function parseMouseEvent(event: MouseEvent): Blazor.MouseEventArgs {\r\n  return {\r\n    detail: event.detail,\r\n    screenX: event.screenX,\r\n    screenY: event.screenY,\r\n    clientX: event.clientX,\r\n    clientY: event.clientY,\r\n    offsetX: event.offsetX,\r\n    offsetY: event.offsetY,\r\n    pageX: event.pageX,\r\n    pageY: event.pageY,\r\n    button: event.button,\r\n    buttons: event.buttons,\r\n    ctrlKey: event.ctrlKey,\r\n    shiftKey: event.shiftKey,\r\n    altKey: event.altKey,\r\n    metaKey: event.metaKey,\r\n    type: event.type,\r\n  } as Blazor.MouseEventArgs;\r\n}\r\n\r\nexport function parseTouchEvent(event: TouchEvent): Blazor.TouchEventArgs {\r\n  return {\r\n    detail: event.detail,\r\n    touches: parseTouch(event.touches),\r\n    targetTouches: parseTouch(event.targetTouches),\r\n    changedTouches: parseTouch(event.changedTouches),\r\n    ctrlKey: event.ctrlKey,\r\n    shiftKey: event.shiftKey,\r\n    altKey: event.altKey,\r\n    metaKey: event.metaKey,\r\n    type: event.type,\r\n  };\r\n}\r\n\r\nfunction parseTouch(touchList: TouchList): Blazor.TouchPoint[] {\r\n  const touches: Blazor.TouchPoint[] = [];\r\n\r\n  for (let i = 0; i < touchList.length; i++) {\r\n    const touch = touchList[i];\r\n    touches.push({\r\n      identifier: touch.identifier,\r\n      clientX: touch.clientX,\r\n      clientY: touch.clientY,\r\n      screenX: touch.screenX,\r\n      screenY: touch.screenY,\r\n      pageX: touch.pageX,\r\n      pageY: touch.pageY,\r\n    });\r\n  }\r\n  return touches;\r\n}\r\n\r\nexport function parseChangeEvent(event: Event): Blazor.ChangeEventArgs {\r\n  const element = event.target as Element;\r\n  if (isTimeBasedInput(element)) {\r\n    const normalizedValue = normalizeTimeBasedValue(element);\r\n    return { value: normalizedValue };\r\n  } else if (isMultipleSelectInput(element)) {\r\n    const selectElement = element as HTMLSelectElement;\r\n    const selectedValues = Array.from(selectElement.options)\r\n      .filter((option) => option.selected)\r\n      .map((option) => option.value);\r\n    return { value: selectedValues };\r\n  } else {\r\n    const targetIsCheckbox = isCheckbox(element);\r\n    const newValue = targetIsCheckbox ? !!element[\"checked\"] : element[\"value\"];\r\n    return { value: newValue };\r\n  }\r\n}\r\n\r\nfunction isTimeBasedInput(element: Element): element is HTMLInputElement {\r\n  return timeBasedInputs.indexOf(element.getAttribute(\"type\")!) !== -1;\r\n}\r\n\r\nconst timeBasedInputs = [\"date\", \"datetime-local\", \"month\", \"time\", \"week\"];\r\n\r\nfunction normalizeTimeBasedValue(element: HTMLInputElement): string {\r\n  const value = element.value;\r\n  const type = element.type;\r\n  switch (type) {\r\n    case \"date\":\r\n    case \"month\":\r\n      return value;\r\n    case \"datetime-local\":\r\n      return value.length === 16 ? value + \":00\" : value; // Convert yyyy-MM-ddTHH:mm to yyyy-MM-ddTHH:mm:00\r\n    case \"time\":\r\n      return value.length === 5 ? value + \":00\" : value; // Convert hh:mm to hh:mm:00\r\n    case \"week\":\r\n      // For now we are not going to normalize input type week as it is not trivial\r\n      return value;\r\n  }\r\n\r\n  throw new Error(`Invalid element type '${type}'.`);\r\n}\r\n\r\nfunction isMultipleSelectInput(element: Element): element is HTMLSelectElement {\r\n  return (\r\n    element instanceof HTMLSelectElement && element.type === \"select-multiple\"\r\n  );\r\n}\r\n\r\nfunction isCheckbox(element: Element | null): boolean {\r\n  return (\r\n    !!element &&\r\n    element.tagName === \"INPUT\" &&\r\n    element.getAttribute(\"type\") === \"checkbox\"\r\n  );\r\n}\r\n","import { parseChangeEvent } from \"./events/EventType\";\r\n\r\nfunction registerInputEvents(\r\n  element: Element,\r\n  onInput: DotNet.DotNetObject,\r\n  debounce: number\r\n) {\r\n  if (\r\n    !(\r\n      element &&\r\n      (element instanceof HTMLInputElement ||\r\n        element instanceof HTMLTextAreaElement)\r\n    )\r\n  )\r\n    return;\r\n\r\n  let compositionInputting = false;\r\n\r\n  let timeout;\r\n\r\n  element.addEventListener(\"compositionstart\", (_) => {\r\n    compositionInputting = true;\r\n  });\r\n\r\n  element.addEventListener(\"compositionend\", (event: CompositionEvent) => {\r\n    compositionInputting = false;\r\n\r\n    const changeEventArgs = parseChangeEvent(event);\r\n    changeEventArgs.value = element.value;\r\n\r\n    if (\r\n      element.maxLength !== -1 &&\r\n      changeEventArgs.value.length > element.maxLength\r\n    ) {\r\n      changeEventArgs.value = changeEventArgs.value.substring(\r\n        0,\r\n        element.maxLength\r\n      );\r\n    }\r\n\r\n    onInput.invokeMethodAsync(\"Invoke\", changeEventArgs);\r\n  });\r\n\r\n  element.addEventListener(\"input\", (event: InputEvent) => {\r\n    if (compositionInputting) return;\r\n\r\n    var changeEventArgs = parseChangeEvent(event);\r\n\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => {\r\n      onInput.invokeMethodAsync(\"Invoke\", changeEventArgs);\r\n    }, debounce);\r\n  });\r\n}\r\n\r\nfunction setValue(element: HTMLInputElement, value: any) {\r\n  element.value = value;\r\n}\r\n\r\nexport { registerInputEvents, setValue };\r\n"],"names":["parseChangeEvent","event","element","target","timeBasedInputs","indexOf","getAttribute","isTimeBasedInput","normalizedValue","value","type","length","Error","normalizeTimeBasedValue","HTMLSelectElement","isMultipleSelectInput","selectElement","Array","from","options","filter","option","selected","map","targetIsCheckbox","tagName","isCheckbox","registerInputEvents","onInput","debounce","HTMLInputElement","HTMLTextAreaElement","timeout","compositionInputting","addEventListener","_","changeEventArgs","maxLength","substring","invokeMethodAsync","clearTimeout","setTimeout","setValue"],"mappings":"AAwDM,SAAUA,EAAiBC,GAC/B,MAAMC,EAAUD,EAAME,OACtB,GAgBF,SAA0BD,GACxB,OAAmE,IAA5DE,EAAgBC,QAAQH,EAAQI,aAAa,QACtD,CAlBMC,CAAiBL,GAAU,CAC7B,MAAMM,EAqBV,SAAiCN,GAC/B,MAAMO,EAAQP,EAAQO,MAChBC,EAAOR,EAAQQ,KACrB,OAAQA,GACN,IAAK,OACL,IAAK,QAML,IAAK,OAEH,OAAOD,EANT,IAAK,iBACH,OAAwB,KAAjBA,EAAME,OAAgBF,EAAQ,MAAQA,EAC/C,IAAK,OACH,OAAwB,IAAjBA,EAAME,OAAeF,EAAQ,MAAQA,EAMhD,MAAM,IAAIG,MAAM,yBAAyBF,MAC3C,CAtC4BG,CAAwBX,GAChD,MAAO,CAAEO,MAAOD,EACjB,CAAM,GAsCT,SAA+BN,GAC7B,OACEA,aAAmBY,mBAAsC,oBAAjBZ,EAAQQ,IAEpD,CA1CaK,CAAsBb,GAAU,CACzC,MAAMc,EAAgBd,EAItB,MAAO,CAAEO,MAHcQ,MAAMC,KAAKF,EAAcG,SAC7CC,QAAQC,GAAWA,EAAOC,WAC1BC,KAAKF,GAAWA,EAAOZ,QAE3B,CAAM,CACL,MAAMe,EAqCV,SAAoBtB,GAClB,QACIA,GACkB,UAApBA,EAAQuB,SACyB,aAAjCvB,EAAQI,aAAa,OAEzB,CA3C6BoB,CAAWxB,GAEpC,MAAO,CAAEO,MADQe,IAAqBtB,EAAiB,QAAIA,EAAe,MAE3E,CACH,CAMA,MAAME,EAAkB,CAAC,OAAQ,iBAAkB,QAAS,OAAQ,QC5EpE,SAASuB,EACPzB,EACA0B,EACAC,GAEA,IAEI3B,KACCA,aAAmB4B,kBAClB5B,aAAmB6B,qBAGvB,OAEF,IAEIC,EAFAC,GAAuB,EAI3B/B,EAAQgC,iBAAiB,oBAAqBC,IAC5CF,GAAuB,CAAI,IAG7B/B,EAAQgC,iBAAiB,kBAAmBjC,IAC1CgC,GAAuB,EAEvB,MAAMG,EAAkBpC,EAAiBC,GACzCmC,EAAgB3B,MAAQP,EAAQO,OAGP,IAAvBP,EAAQmC,WACRD,EAAgB3B,MAAME,OAAST,EAAQmC,YAEvCD,EAAgB3B,MAAQ2B,EAAgB3B,MAAM6B,UAC5C,EACApC,EAAQmC,YAIZT,EAAQW,kBAAkB,SAAUH,EAAgB,IAGtDlC,EAAQgC,iBAAiB,SAAUjC,IACjC,IAAIgC,EAAJ,CAEA,IAAIG,EAAkBpC,EAAiBC,GAEvCuC,aAAaR,GACbA,EAAUS,YAAW,KACnBb,EAAQW,kBAAkB,SAAUH,EAAgB,GACnDP,EAP8B,CAOrB,GAEhB,CAEA,SAASa,EAASxC,EAA2BO,GAC3CP,EAAQO,MAAQA,CAClB"}